Лекция 11
Приложение под ОС Windows в Python

Цель лекции. Изучить приложение ОС Windows, его основные характеристики и принцип работы с ним. Разобрать назначение окон присутствующих в GUI приложениях на Python.

11.1. Основные характеристики приложения GUI в Python
При создании GUI приложений в Python предоставляется возможность использовать различные библиотеки для создания графического интерфейса под операционную систему Windows:

- tkinter (встроенная библиотека)
- PyQt5/PyQt6
- PySide2/PySide6
- wxPython
- Kivy

tkinter является стандартной библиотекой Python и не требует дополнительной установки. Она позволяет создавать приложения с графическим интерфейсом, отличающиеся небольшими размерами исполняемого файла.

Основные компоненты tkinter:
- Главное окно (Tk)
- Виджеты (компоненты интерфейса)
- События и обработчики
- Менеджеры размещения (pack, grid, place)

11.2 Основные виджеты tkinter
Окно содержит:
Строку заголовка, которая отображает имя приложения;
Строку меню с набором команд для разработки, тестирования приложений;
Панель инструментов с кнопками, соответствующие основным командам;
Область содержимого – средство отображения приложения;
Виджеты (компоненты) для создания графического интерфейса.

Элементы подразделяются на:
Визуальные (кнопки, меню, поля редактирования, переключатели, списки…), 
Логические (окна диалога, отчеты, часы…), отображающиеся в процессе запуска приложения.

11.3 Создание простого GUI приложения
Простейшее приложение представляет собой заготовку, обеспечивающую все необходимое для приложения. Это главное окно, для которого уже созданы базовые настройки.

Форма отображается при первом запуске и содержит основные элементы окна Windows: 
заголовок приложения, 
кнопки минимизации, максимизации и закрытия окна, изменения размеров окна.

При создании приложений на форму помещаются виджеты, для которых устанавливаются свойства и создаются обработчики событий.

Пример простейшего приложения:
import tkinter as tk
from tkinter import ttk

class SimpleApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Простое приложение")
        self.root.geometry("400x300")
        
        # Создание виджетов
        self.create_widgets()
    
    def create_widgets(self):
        # Метка
        self.label = tk.Label(self.root, text="Добро пожаловать!")
        self.label.pack(pady=10)
        
        # Кнопка
        self.button = tk.Button(self.root, text="Нажми меня", command=self.on_button_click)
        self.button.pack(pady=5)
        
        # Поле ввода
        self.entry = tk.Entry(self.root, width=30)
        self.entry.pack(pady=5)
        
        # Текстовое поле
        self.text = tk.Text(self.root, height=5, width=40)
        self.text.pack(pady=5)
    
    def on_button_click(self):
        text = self.entry.get()
        self.text.insert(tk.END, f"Вы ввели: {text}\n")
        self.entry.delete(0, tk.END)

# Создание и запуск приложения
if __name__ == "__main__":
    root = tk.Tk()
    app = SimpleApp(root)
    root.mainloop()

11.4 Свойства виджетов
Свойства виджета это атрибуты, определяющие способ отображения и функционирования компонента.

Типы свойств:
простые – это те, значения которых являются числами или строками. Например, text, width, height, bg, fg;
перечисляемые – это те, которые могут принимать значения из предложенного набора (списка). Например, relief, cursor, state;
вложенные – это те, которые поддерживают вложенные значения (или объекты). Например, font, padx, pady.

Изменять свойства виджетам можно двумя способами:
При создании виджета (в конструкторе);
Программно – путем создания соответствующих методов с соответствующими строками кода.

При выполнении приложения свойства компонентов можно изменять с помощью операторов присваивания.

Например:
# изменение программно надписи кнопки button1:
self.button.config(text="Решить")

# изменение размеров текстового поля:
self.text.config(height=10, width=50)

# изменение текста и цвета шрифта в метке:
self.label.config(text="Студент", fg="red")

11.5 События и обработчики
Событие – это то, что происходит во время работы программы. В Python каждому событию присваивается имя.
Реакция окна на разного рода действия пользователя определяет функциональность приложения.

Обработчик событий – определяет действие, которое можно поручить выделенному компоненту. Каждый компонент имеет набор стандартных обработчиков событий.

Основные события:
- Button: <Button-1> (щелчок левой кнопкой мыши)
- Entry: <KeyPress>, <FocusIn>, <FocusOut>
- Text: <KeyPress>, <Button-1>
- Window: <Configure>, <Destroy>

Пример создания обработчика событий:
import tkinter as tk
from tkinter import messagebox

class EventApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Приложение с событиями")
        self.root.geometry("400x300")
        
        self.create_widgets()
        self.bind_events()
    
    def create_widgets(self):
        self.label = tk.Label(self.root, text="Нажмите кнопку или введите текст")
        self.label.pack(pady=10)
        
        self.button = tk.Button(self.root, text="Кнопка")
        self.button.pack(pady=5)
        
        self.entry = tk.Entry(self.root, width=30)
        self.entry.pack(pady=5)
        
        self.text = tk.Text(self.root, height=5, width=40)
        self.text.pack(pady=5)
    
    def bind_events(self):
        # Обработчик клика по кнопке
        self.button.bind('<Button-1>', self.on_button_click)
        
        # Обработчик нажатия клавиши в поле ввода
        self.entry.bind('<KeyPress>', self.on_key_press)
        
        # Обработчик изменения размера окна
        self.root.bind('<Configure>', self.on_window_resize)
    
    def on_button_click(self, event):
        self.label.config(text="Кнопка нажата!")
        self.text.insert(tk.END, "Кнопка была нажата\n")
    
    def on_key_press(self, event):
        self.label.config(text=f"Нажата клавиша: {event.char}")
    
    def on_window_resize(self, event):
        if event.widget == self.root:
            self.text.insert(tk.END, f"Окно изменено: {event.width}x{event.height}\n")

if __name__ == "__main__":
    root = tk.Tk()
    app = EventApp(root)
    root.mainloop()

11.6 Менеджеры размещения
В tkinter существует три основных менеджера размещения:

1. pack() - размещение в блоках
2. grid() - размещение в сетке
3. place() - абсолютное размещение

Пример использования grid():
import tkinter as tk
from tkinter import ttk

class GridApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Приложение с сеткой")
        self.root.geometry("400x300")
        
        self.create_widgets()
    
    def create_widgets(self):
        # Создание виджетов с размещением в сетке
        tk.Label(self.root, text="Имя:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.name_entry = tk.Entry(self.root, width=20)
        self.name_entry.grid(row=0, column=1, padx=5, pady=5)
        
        tk.Label(self.root, text="Возраст:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.age_entry = tk.Entry(self.root, width=20)
        self.age_entry.grid(row=1, column=1, padx=5, pady=5)
        
        tk.Button(self.root, text="Сохранить", command=self.save_data).grid(row=2, column=0, padx=5, pady=5)
        tk.Button(self.root, text="Очистить", command=self.clear_data).grid(row=2, column=1, padx=5, pady=5)
        
        self.result_text = tk.Text(self.root, height=10, width=40)
        self.result_text.grid(row=3, column=0, columnspan=2, padx=5, pady=5)
    
    def save_data(self):
        name = self.name_entry.get()
        age = self.age_entry.get()
        self.result_text.insert(tk.END, f"Имя: {name}, Возраст: {age}\n")
    
    def clear_data(self):
        self.name_entry.delete(0, tk.END)
        self.age_entry.delete(0, tk.END)
        self.result_text.delete(1.0, tk.END)

if __name__ == "__main__":
    root = tk.Tk()
    app = GridApp(root)
    root.mainloop()

11.7 Диалоговые окна
tkinter предоставляет стандартные диалоговые окна:

import tkinter as tk
from tkinter import messagebox, filedialog, colorchooser

class DialogApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Приложение с диалогами")
        self.root.geometry("400x300")
        
        self.create_widgets()
    
    def create_widgets(self):
        tk.Button(self.root, text="Сообщение", command=self.show_message).pack(pady=5)
        tk.Button(self.root, text="Предупреждение", command=self.show_warning).pack(pady=5)
        tk.Button(self.root, text="Ошибка", command=self.show_error).pack(pady=5)
        tk.Button(self.root, text="Вопрос", command=self.show_question).pack(pady=5)
        tk.Button(self.root, text="Открыть файл", command=self.open_file).pack(pady=5)
        tk.Button(self.root, text="Сохранить файл", command=self.save_file).pack(pady=5)
        tk.Button(self.root, text="Выбрать цвет", command=self.choose_color).pack(pady=5)
    
    def show_message(self):
        messagebox.showinfo("Информация", "Это информационное сообщение")
    
    def show_warning(self):
        messagebox.showwarning("Предупреждение", "Это предупреждение")
    
    def show_error(self):
        messagebox.showerror("Ошибка", "Это сообщение об ошибке")
    
    def show_question(self):
        result = messagebox.askyesno("Вопрос", "Вы уверены?")
        if result:
            messagebox.showinfo("Ответ", "Вы ответили 'Да'")
        else:
            messagebox.showinfo("Ответ", "Вы ответили 'Нет'")
    
    def open_file(self):
        filename = filedialog.askopenfilename()
        if filename:
            messagebox.showinfo("Файл", f"Выбран файл: {filename}")
    
    def save_file(self):
        filename = filedialog.asksaveasfilename()
        if filename:
            messagebox.showinfo("Файл", f"Файл будет сохранен как: {filename}")
    
    def choose_color(self):
        color = colorchooser.askcolor()
        if color[1]:
            messagebox.showinfo("Цвет", f"Выбран цвет: {color[1]}")

if __name__ == "__main__":
    root = tk.Tk()
    app = DialogApp(root)
    root.mainloop()

11.8 Меню и панели инструментов
import tkinter as tk
from tkinter import ttk, messagebox

class MenuApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Приложение с меню")
        self.root.geometry("500x400")
        
        self.create_menu()
        self.create_toolbar()
        self.create_widgets()
    
    def create_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # Файл
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Файл", menu=file_menu)
        file_menu.add_command(label="Новый", command=self.new_file)
        file_menu.add_command(label="Открыть", command=self.open_file)
        file_menu.add_separator()
        file_menu.add_command(label="Выход", command=self.root.quit)
        
        # Правка
        edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Правка", menu=edit_menu)
        edit_menu.add_command(label="Копировать", command=self.copy)
        edit_menu.add_command(label="Вставить", command=self.paste)
        
        # Справка
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Справка", menu=help_menu)
        help_menu.add_command(label="О программе", command=self.about)
    
    def create_toolbar(self):
        toolbar = ttk.Frame(self.root)
        toolbar.pack(side=tk.TOP, fill=tk.X)
        
        ttk.Button(toolbar, text="Новый", command=self.new_file).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Открыть", command=self.open_file).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Сохранить", command=self.save_file).pack(side=tk.LEFT, padx=2)
        
        ttk.Separator(toolbar, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=5)
        
        ttk.Button(toolbar, text="Копировать", command=self.copy).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Вставить", command=self.paste).pack(side=tk.LEFT, padx=2)
    
    def create_widgets(self):
        self.text = tk.Text(self.root, wrap=tk.WORD)
        self.text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    def new_file(self):
        self.text.delete(1.0, tk.END)
        messagebox.showinfo("Файл", "Создан новый файл")
    
    def open_file(self):
        messagebox.showinfo("Файл", "Открытие файла")
    
    def save_file(self):
        messagebox.showinfo("Файл", "Сохранение файла")
    
    def copy(self):
        messagebox.showinfo("Правка", "Копирование")
    
    def paste(self):
        messagebox.showinfo("Правка", "Вставка")
    
    def about(self):
        messagebox.showinfo("О программе", "Простое GUI приложение на Python")

if __name__ == "__main__":
    root = tk.Tk()
    app = MenuApp(root)
    root.mainloop()

11.9 Обработка ошибок в GUI приложениях
import tkinter as tk
from tkinter import messagebox

class ErrorHandlingApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Приложение с обработкой ошибок")
        self.root.geometry("400x300")
        
        self.create_widgets()
    
    def create_widgets(self):
        tk.Label(self.root, text="Введите два числа:").pack(pady=5)
        
        self.entry1 = tk.Entry(self.root, width=20)
        self.entry1.pack(pady=5)
        
        self.entry2 = tk.Entry(self.root, width=20)
        self.entry2.pack(pady=5)
        
        tk.Button(self.root, text="Сложить", command=self.add_numbers).pack(pady=5)
        tk.Button(self.root, text="Разделить", command=self.divide_numbers).pack(pady=5)
        
        self.result_label = tk.Label(self.root, text="Результат появится здесь")
        self.result_label.pack(pady=10)
    
    def add_numbers(self):
        try:
            num1 = float(self.entry1.get())
            num2 = float(self.entry2.get())
            result = num1 + num2
            self.result_label.config(text=f"Сумма: {result}")
        except ValueError:
            messagebox.showerror("Ошибка", "Пожалуйста, введите корректные числа")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")
    
    def divide_numbers(self):
        try:
            num1 = float(self.entry1.get())
            num2 = float(self.entry2.get())
            if num2 == 0:
                raise ZeroDivisionError("Деление на ноль")
            result = num1 / num2
            self.result_label.config(text=f"Частное: {result}")
        except ValueError:
            messagebox.showerror("Ошибка", "Пожалуйста, введите корректные числа")
        except ZeroDivisionError:
            messagebox.showerror("Ошибка", "Деление на ноль невозможно")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

if __name__ == "__main__":
    root = tk.Tk()
    app = ErrorHandlingApp(root)
    root.mainloop()

11.10 Создание исполняемого файла
Для создания исполняемого файла из Python приложения можно использовать PyInstaller:

# Установка PyInstaller
# pip install pyinstaller

# Создание исполняемого файла
# pyinstaller --onefile --windowed your_app.py

# --onefile: создает один исполняемый файл
# --windowed: скрывает консольное окно для GUI приложений

Краткие итоги. В лекции были рассмотрены вопросы, относящиеся к созданию GUI приложений в Python. Даны основные характеристики tkinter. Описан процесс создания приложения с графическим интерфейсом. Рассмотрены основные виджеты, события и обработчики.

Контрольные вопросы
Перечислите основные библиотеки для создания GUI в Python.
Перечислите основные виджеты tkinter.
Что необходимо для размещения виджета в окне.
Что отражают свойства виджетов?
Дайте краткую характеристику tkinter.
Перечислите этапы разработки GUI приложения.
Что необходимо для создания интерфейса?
Как обеспечить функциональность приложения?
Перечислите типы свойств виджетов.
Как можно изменить свойства виджета?
Приведите примеры изменения свойств виджета.
Дайте определение понятию «Событие» в GUI.
Какие менеджеры размещения существуют в tkinter?
Как создать диалоговое окно в tkinter?
Как обработать ошибки в GUI приложении?
