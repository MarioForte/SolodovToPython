Лекция 10
Исключения в Python

Цель лекции. Разобраться что такое исключения, как они проявляются в работе. Изучить обработку исключения, какие обработчики используются.

Нарушение в работе программы (не корректное действие) называется исключением. Исключение останавливает текущий поток программы и если никакие меры не предпринимаются, программа просто прекращает выполнение. Причиной исключений могут быть ошибки в программе (например, деление числа на ноль) или неожиданный ввод (например, выбор несуществующего файла, или вместо цифры для выполнения арифметических действий – буква). Задачей пользователя является предоставление программе возможности устранить проблемы, не приводя к сбою.

Обработку исключений может выполнять:
системный обработчик исключений или
написанный пользователем программный код, который выводит сообщение.

Для обработки исключений используются глобальные и локальные обработчики исключений. 
Глобальные обработчики – стандартные предусмотрены операционной системой и вызываются автоматически, если отладчик подключен. Обработчик завершает выполнение программы, выдавая информацию о возникновении исключения. Он не всегда понятен пользователю, не говоря уже о досрочном завершении программы.

Локальные обработчики создает сам пользователь в виде сообщений. Программист может перехватить исключительные ситуации и сделать их обработку, после чего продолжится нормальный ход вычислений приложения.
Обработка локальных исключений в Python реализована с помощью ключевых слов — try, except, else и finally — с помощью которых программа обнаруживает исключения, устраняет их и продолжает выполнение. Они способствуют повышению надежности приложений.

10.1 Виды исключений:
Исключения имеют типы, являющиеся производными от BaseException. Некоторые исключения, генерируемые при выполнении:

Таблица 10.1
Типы исключений и их описание в Python

Тип исключения | Описание
---------------|----------
ZeroDivisionError | Деление на ноль
IndexError | Индекс списка вне диапазона
KeyError | Ключ не найден в словаре
ValueError | Неправильное значение
TypeError | Неправильный тип данных
FileNotFoundError | Файл не найден
NameError | Переменная не определена
AttributeError | Атрибут не найден
ImportError | Ошибка импорта модуля
KeyboardInterrupt | Прерывание с клавиатуры (Ctrl+C)
SystemExit | Выход из программы

10.2 Типы блоков работающих с исключением
Существуют несколько типов блоков:
I.   try … except   # попробовать исключить
II.   try … except … else   # попробовать исключить с альтернативой
III.   try … except … finally   # попробовать исключить в финал
IV.   try … except … else … finally   # полная форма

I. Try, Except
Ключевые слова try и except используются вместе как составной оператор. Для таких блоков характерна вложенность. Если предполагается, что блок кода может вызвать исключение, используют ключевое слово try и except (тип_исключения), чтобы сохранить код, который будет выполнен при возникновении исключения. 

Блок, которому предшествует ключевое слово try, называется охраняемым (контролируемым) блоком или try-блоком. Блок, которому предшествует конструкция except (тип_исключения), называется блоком перехватчиком исключения или except-блоком.
При отсутствии блоков try и except произойдет сбой программы.

Синтаксис инструкции:
try:
    # Блок кода, подлежащий проверки на наличие ошибок 
except ТипИсключения1:
    # Код обработчика исключения (ТипИсключения1)
except ТипИсключения2:
    # Код обработчика исключения (ТипИсключения2)
except:
    # Обработчик для всех остальных исключений

С try-блоком может быть связана не одна, а несколько except-инструкций. Какая из них будет выполнена, определит тип исключения. Будет выполнена та except-инструкция, тип исключения которой совпадает с типом сгенерированного исключения (а все остальные будут проигнорированы). 
Если исключение не сгенерируется, то try-блок завершается нормально, и все его except-инструкции игнорируются. Выполнение программы продолжается с первой инструкции, которая стоит после последней инструкции except. Таким образом, except-инструкция выполняется только в случае, если сгенерировано соответствующее исключение.

Пример 1, в котором в результате деления на ноль создается исключение, которое затем перехватывается. В программе генерируется исключение типа ZeroDivisionError – деление на 0

x = 0
y = 0  # знаменатель равен 0
try:
    x = 10 / y  # Проверяемая инструкция, возможно деление на 0
    print(f"Ответ x= {x}")
except ZeroDivisionError:  # Обработчик исключения
    print("Попытка деления на 0.")

Блоки try включают операторы программы, которые могут вызвать исключительную ситуацию, например y=0.  
Теперь заменим y=0 на y=2:

x = 0
y = 2  # знаменатель равен, например 2 (отличен от 0)
try:
    x = 10 / y  # Проверяемая инструкция, возможно деление на 0
    print(f"Ответ x= {x}")
except ZeroDivisionError:  # Обработчик исключения
    print("Попытка деления на 0.")

Пример 2, в котором происходит индексация списка и попытка индексировать список за пределами его границ, вызывает ошибку нарушения диапазона.

def main():
    N = [0] * 4  # список для 4-х элементов
    try:
        print("Перед генерированием исключения.")
        # связанное с попаданием индекса вне диапазона
        for i in range(10):  # в цикле индексируется список от 0 до 9
            N[i] = i
            print(f"N[{i}]:{N[i]}")
        print("Этот текст не отображается")
    except IndexError:
        # Перехватываем исключение.
        print("Индекс вне диапазона")
    print("После except-инструкции")
    input()

if __name__ == "__main__":
    main()

В программе намеренно генерируется исключение типа IndexError, а затем это исключение перехватывается. 
В программе объявляется список для 4-х элементов, а в цикле делается попытка индексировать этот список от 0 до 9. Как только значение индекса устанавливается равным четырем, генерируется исключение типа IndexError.

Ключевые аспекты обработки исключений:
1. проверяемый код содержится внутри try-блока,
2. при возникновении исключения выполнение try-блока прекращается, а само исключение перехватывается except инструкцией,
3. except инструкция не вызывается, а ей передается управление программой.
4. после выполнения except инструкции программа продолжится со следующей инструкции.

Если try-блоком исключение не сгенерировано, ни одна из except инструкций не выполняется и управление программой будет передано инструкции, следующей за except инструкций. 
Если заменить в цикле for i in range(10) верхний индекс на for i in range(len(N)), то границы индексирования списка не нарушаются. Поэтому исключение не генерируется и except-блок не выполняется.

Если не создать локального обработчика исключения, то Python система динамического управления перехватит исключение, сообщит об ошибке и завершит программу.

С try-блоком можно связать несколько except инструкций. Все except инструкции должны перехватывать исключения различного типа. 

Пример 3. Программа перехватывает как ошибку нарушения границ списка, так и ошибку деления на нуль.

def main():
    N = [4, 8, 16, 32, 64, 128, 256, 512]  # список из 8 элементов
    D = [2, 0, 4, 4, 0, 8]  # список из 6 элементов
    for i in range(len(N)):  # в цикле по всем элементам 
        try:
            print(f"{N[i]} / {D[i]} = {N[i]/D[i]}")
        except ZeroDivisionError:
            # Перехватываем исключение.
            print("На нуль делить нельзя!")
        except IndexError:
            # Перехватываем исключение.
            print("Нет соответствующего элемента.")
    input()

if __name__ == "__main__":
    main()

Каждая except инструкция реагирует только на собственный тип исключения.

II. Try, Except, Else
Блок else выполняется только если в try-блоке не возникло исключений.

try:
    # Код, который может вызвать исключение
    result = 10 / 2
except ZeroDivisionError:
    print("Деление на ноль!")
else:
    print(f"Результат: {result}")

III. Try, Except, Finally
Иногда возникает потребность определить программный блок, который должен выполняться по выходу из try/except блока. Исключение может вызвать ошибку, которая является причиной преждевременного возврата из текущего метода. Удобный путь выхода из этого – блок finally.
Код, содержащийся в блоке finally, выполняется всегда, вне зависимости от возникновения исключения. Чтобы гарантировать возвращение ресурсов, например, убедиться, что файл закрыт, или освободить память от локальных переменных.

Синтаксис инструкции:
try:
    # Блок кода, предназначенный для обработки ошибок
except ТипИсключения1:
    # Обработчик для исключения (ТипИсключения1).
except ТипИсключения2:
    # Обработчик для исключения (ТипИсключения2).
finally:
    # Код завершения обработки исключений.

Не зависимо от итога выполнения try/except блоков, блок finally выполняется обязательно.

Пример 4. Используя закон Ома рассчитать величину тока. Проект консольное приложение.

def calculate_current():
    try:
        U = int(input("Введите напряжение (U): "))  # преобразование строкового
        R = int(input("Введите сопротивление (R): "))  # отображения в целое
        I = U / R
        print(f"Ток I = {I:.2f} A")  # преобразование числа в строку
    except ValueError:
        print("Нельзя вводить буквы и символы")
    except ZeroDivisionError:
        print("Сопротивление не может быть равно нулю")
    finally:
        print("Расчет завершен")

if __name__ == "__main__":
    calculate_current()

10.3 Создание собственных исключений
В Python можно создавать собственные классы исключений, наследуя их от базового класса Exception.

class CustomError(Exception):
    """Пользовательское исключение"""
    pass

def check_positive_number(value):
    if value < 0:
        raise CustomError("Число должно быть положительным")
    return value

try:
    result = check_positive_number(-5)
except CustomError as e:
    print(f"Ошибка: {e}")

10.4 Обработка исключений с получением информации
Можно получить дополнительную информацию об исключении:

try:
    x = 10 / 0
except ZeroDivisionError as e:
    print(f"Ошибка: {e}")
    print(f"Тип ошибки: {type(e).__name__}")

10.5 Форматы ввода/вывода
При вводе и выводе информации в языке Python используются функции преобразования:

Таблица 10.2
Функции преобразования и их значения в Python

Функция | Описание | Пример
--------|----------|-------
int() | Преобразование в целое число | int("123") → 123
float() | Преобразование в вещественное число | float("3.14") → 3.14
str() | Преобразование в строку | str(123) → "123"
bool() | Преобразование в логическое значение | bool(1) → True
list() | Преобразование в список | list("abc") → ['a', 'b', 'c']
tuple() | Преобразование в кортеж | tuple([1,2,3]) → (1, 2, 3)
dict() | Преобразование в словарь | dict([('a',1)]) → {'a': 1}

Например, для консольного приложения:
x = float(input())  # вещественный тип
d = int(input())  # целый тип 
z = int(input())  # целый тип
ch = input()[0]  # символьный тип (первый символ)
print(f"x={x:3.2f} y={y:5.2f}")  # форматный вывод переменных х и у, 
# где 3 и 5 – количество выводимых символов, 
# 2 – два символа после запятой

10.6 Обработка исключений при работе с файлами
Пример безопасной работы с файлами:

def read_file_safely(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            content = file.read()
            print("Файл успешно прочитан")
            return content
    except FileNotFoundError:
        print(f"Файл {filename} не найден")
    except PermissionError:
        print(f"Нет прав доступа к файлу {filename}")
    except Exception as e:
        print(f"Произошла ошибка: {e}")
    finally:
        print("Обработка файла завершена")

# Использование
content = read_file_safely("example.txt")

10.7 Контекстные менеджеры (with)
Python предоставляет удобный способ работы с ресурсами через контекстные менеджеры:

# Автоматическое закрытие файла
with open("file.txt", "r") as f:
    content = f.read()
# Файл автоматически закроется здесь

# Создание собственного контекстного менеджера
class MyContextManager:
    def __enter__(self):
        print("Вход в контекст")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Выход из контекста")
        if exc_type:
            print(f"Произошло исключение: {exc_val}")
        return False  # Не подавлять исключение

# Использование
with MyContextManager() as cm:
    print("Работа в контексте")
    # raise ValueError("Тестовая ошибка")

Краткие итоги. В лекции были рассмотрены исключения, и работа с ними, посредством обработчиков. Приведены примеры работы блоков работающих с исключениями. Рассмотрены особенности Python в обработке исключений.

Контрольные вопросы.
Дайте определение понятию «исключение» в Python.
Как можно выполнить обработку исключений?
Перечислите обработчики исключений и их принцип работы.
Виды исключений, типы и описания в Python.
Блоки, работающие с исключениями, коротко охарактеризуйте их.
Ключевые слова try и except, как они используются в блоке исключения.
Приведите пример использования try и except.
Ключевые аспекты обработки исключения при использования try и except.
Программный блок использующий try, except, finally.
Приведите пример использования try, except, finally.
Функции преобразования и их значения в Python.
Приведите примеры формата ввода и вывода.
Как создать собственное исключение в Python?
Что такое контекстные менеджеры?
