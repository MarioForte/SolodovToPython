Лекция 9
Классы, объекты и методы. Подпрограммы

Цель лекции. Изучить классы, объекты и методы, их характеристики, определение, свойства и как они представляются. Рассмотреть подпрограммы их преимущества, дать определение.

9.1 Введение в классы, объекты и методы
Программирование в C# построено на классах. У класса  две различные роли:
модуля и 
типа данных.
Класс – это некий шаблон (модуль), который определяет форму объекта. Или множество объектов, связанных общностью структуры и поведения. Класс определяет, как должен быть построен объект. Однотипные объекты могут объединяться в классы (группы).
Конкретный объект, имеющий структуру этого класса, называется экземпляром класса. 
Например,  объект кнопка button1 – это экземпляр класса кнопок Button. Сам класс определяется общими свойствами, которые имеют все экземпляры этого класса.
Модульность построения – основное свойство программных систем. Система, построенная по модульному принципу, состоит из классов, являющихся основным видов модуля. Можно построить монолитную систему, состоящую из одного модуля, решающая ту же задачу, что и система, состоящая из нескольких простых модулей. Большую систему, создаваемую коллективом разработчиков, без разделения системы на модули построить не удается. Поэтому модульность построения – основное средство борьбы со сложностью системы.
Класс – это особый тип записи, имеющий в своем составе поля, свойства и методы обработки. Каждый модуль имеет содержательную начинку. Класс становится. Модулем и имеет  определенное назначение. В основе класса лежит абстрактный тип данных.
Поля класса служат для хранения информации об объекте. Одной стороны, свойства можно использовать как поля, например, присваивать им значения с помощью оператора присваивания, с другой стороны, внутри класса доступ к значениям свойств выполняется методами класса.
Методами называются процедуры и функции, предназначенные для обработки внутренних данных объекта данного класса (полей). Объект может обладать набором заранее встроенных методов обработки, созданных пользователем, которые выполняются при наступлении заранее определенных событий, например: нажатие кнопки мыши, определенной клавиши, выбор пункта меню и т.п..
Свойства – характеристики объекта, его параметры. Объект представляется с помощью присущих ему свойств.
Например:
   ОБЪЕКТ_1 (свойство-1, свойство-2, . . . свойство-k).
Свойства объектов различных классов могут пересекаться. Например:
   ОБЪЕКТ_А (. . свойство-n, свойство-m, . . . свойство-k).

   ОБЪЕКТ_B (свойство-1,. . . свойство-n, . . . свойство-k).

9.2 Синтаксис класса
class <Имя класса> [: список родителей]
{                 
                                                 //объявление переменных экземпляра
  доступ   тип   переменная1;
  доступ   тип   переменная2;
  . . . . . . . . . . 
  доступ   тип   переменнаяN;
                                                  //объявление методов
   доступ   тип_возврата   метод1(параметры)
      {
        // тело метода1
      }
   доступ   тип_возврата   метод2(параметры)
      {
        // тело метода2
      }
   . . . . . . . . .
   доступ   тип_возврата   методN(параметры)
      {
        // тело методаN
      }
}
Доступ – означает спецификатор доступа, принимающий одно из четырех значений:  public,  private,  protected, internal. Он определяет, как к этому члену можно получить доступ. Члены класса могут быть закрытыми в рамках класса или более доступными. 
Например, спецификатор public – общедоступные описания означает, что класс открыт и члены класса могут использовать все составные части программного кода . 
Спецификаторы private или protected – означают, что члены класса закрыты для пользователя.
Правильно определенный класс должен содержать логически связанные данные.
Все переменные, объявленные на уровне класса, являются полями класса.
Поля задают представления абстракции данных, которую реализует класс.
Поля характеризуют свойства объектов класса.
Описаниями класса являются объявления свойств, методов и событий.
Метод представляет собой подпрограмму, являющуюся элементом класса. Методы выполняют действия над объектами класса. Все объекты одного класса имеют один и тот же набор методов.
Классы, которые мы использовали до сих пор, содержат один метод Main().

static void Main(string[] args)
        {
        }

9.3. Основные понятия подпрограммы
Подпрограмма – логически законченная часть программы, которую по имени можно вызывать в разные места программы неограниченное число раз. 
Она решает часть общей задачи. У нее есть имя, которое используется при вызове подпрограммы в основную программу.
Подпрограммы бывают 2 видов: 
процедуры и 
функции.
Функция отличается от процедуры двумя особенностями:
всегда вычисляет некоторое (одно) значение, возвращаемое в качестве результата функции, 
функция вызывается в выражениях.
Процедура в C# имеет свои особенности:
возвращает формальный результат void, который указывает на отсутствие результата, возвращаемого при вызове процедуры,
вызов процедуры является оператором языка, 
имеет входные и выходные аргументы, причем выходных аргументов – ее результатов – может быть достаточно много.
Обычно метод реализуется в виде функции тогда, когда он имеет один выходной аргумент, рассматриваемый как результат вычисления функции (например, sin(0.5)).
В других случаях метод реализуют в виде процедуры.
Программа без структурных элементов называется монолитной. Минимальный элемент такой  программы – оператор (инструкция). Она сложна в разработке, отладке и сопровождении.
Структурированная программа называется модульной. Она содержит более крупные компоненты –  подпрограммы. Модульная программа проще создается, более понятна.
Программа на языке C# строится из модулей, роль которых играют классы, но каждый из этих модулей имеет содержательную начинку.
Процедуры и функции связываются с классом, они обеспечивают требуемую функциональность класса и называются методами класса. Существуют только как методы некоторого класса и не существуют вне класса.
Синтаксис объявления метода позволяет однозначно определить, чем является метод – процедурой или функцией.
Работа с подпрограммой включает 2 этапа:
описание метода;
вызов метода.
Преимущества подпрограммы:
1. в программе нет дублирования кода;
2. повышается надежность программы;
3. улучшается «читаемость» программы;
4. облегчается процесс отладки.
Различают подпрограммы:
без параметров (), 
с параметрами (params).

9.4Сравнение вариантов
Рассмотрим 2 варианта решения одной и той же задачи: 
Вывод текстовых блоков со вставкой стандартного разделителя из трех строк из набора символов  " * " в конце.
1 –й вариант (Монолитная программа)
static void Main(string[] args)
     {               
           Console.WriteLine("Текст и разделители");
           Console.WriteLine();
           Console.WriteLine("Текст 1");  // Вывод 1 текста
           for (int i = 0; i < 3; i++)
             {
               for (int j = 0; j < 20; j++)                 
               Console.Write("*");
               Console.WriteLine();   // Вывод строк разделителя
             }
           Console.WriteLine();
           Console.WriteLine("Текст 2");  // Вывод 2 текста
           for (int i = 0; i < 3; i++)
             {
               for (int j = 0; j < 20; j++)
               Console.Write("*");
               Console.WriteLine();   // Вывод строк разделителя
            }
           Console.WriteLine();
           Console.WriteLine("Текст 3");  // Вывод 3 текста
           for (int i = 0; i < 3; i++)
             {
               for (int j = 0; j < 20; j++)
                   Console.Write("*");
               Console.WriteLine();   // Вывод строк разделителя
             }
          Console.ReadLine();
     }




2 – й вариант (Модульная программа)
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace ConsoleApplication1
{
    class Program
    {
     static void DrawStr()  // Процедура "Рисовать строки" без параметров
        {
            for (int i = 0; i < 3; i++)
            {
              for (int j = 0; j < 20; j++)
              Console.Write("*");
              Console.WriteLine();// Вывод строк разделителя
            }
        }
        static void Main(string[] args)
        {
            Console.WriteLine("Текст и разделители");
            Console.WriteLine();
            Console.WriteLine("Текст 1"); // Вывод 1 текста
            DrawStr();                        // Вызов процедуры "Рисовать строки"
            Console.WriteLine();
            Console.WriteLine("Текст 2"); // Вывод 2 текста
            DrawStr();                        // Вызов процедуры "Рисовать строки"              
            Console.WriteLine();
            Console.WriteLine("Текст 3"); // Вывод 3 текста
            DrawStr();                        // Вызов процедуры "Рисовать строки"
            Console.ReadLine();
        } 
    }
}





9.5 Описание методов (процедур и функций)
Синтаксически в описании метода различают две части:
Описание заголовка
Описание тела метода.
ЗАГОЛОВОК_МЕТОДА
ТЕЛО_МЕТОДА
Синтаксис заголовка процедуры:

Синтаксис заголовка функции

имя_метода ([список параметров]) составляют сигнатуру метода

        –  обязательная часть в заголовке метода,
 [ ] показывают, что атрибуты и модификаторы могут быть опущены при описании метода.
Модификаторы:
static – представляет стандартный поток для консольного приложения,
public – показывает, что метод открыт и доступен для вызова пользователем и потомками класса,
private – говорит, что метод закрыт и предназначен для внутреннего использования в классе и доступен для вызова только в теле методов самого класса. 
Если модификатор опущен, то метод является закрытым для пользователя и класса.
Примеры описания методов:
void A() {…};
int B() {…};
public   void C() {…};
Методы А и В являются закрытыми, а метод С – открыт.
Методы А и С реализованы процедурами, а метод B – функцией, возвращающей целое значение (int),  {…} –  тело метода.
 
9.6 Аргументы и параметры
Параметры – данные, с которыми работает подпрограмма. Это внутренние данные для подпрограммы и перечисляются в ее заголовке с указанием типов. Список может содержать фиксированное число аргументов, разделяемых запятой – для подпрограммы с параметрами или быть пустым – для подпрограммы без параметров.
Синтаксис объявления двух параметров:
[ ref | out | params] тип_аргумента1 имя_аргумента1, тип_аргумента2 имя_аргумента2
Например: (out  long p1, int p2);
Параметры связаны с аргументами.
Аргументы – данные, передаваемые в подпрограмму или возвращаемые из нее. Это внешние для подпрограммы данные, с которыми имеет дело вызывающая часть программы. В подпрограмме им соответствуют параметры. Указываются в списке аргументов при обращении к подпрограмме и являются фактическими параметрами.
Синонимы:
Параметры = формальные параметры, условно Р.
Аргументы =  фактические аргументы, условно А.
Можно для фиксированного числа формальных параметров передать методу произвольное число фактических аргументов. Для этого в списке формальных параметров необходимо задать ключевое слово  params. Оно может появляться в объявлении лишь последнего аргумента списка, объявленного как массив произвольного типа. При вызове метода этому параметру соответствует произвольное число фактических аргументов.
Для аргументов и параметров надо соблюдать:
одинаковое количество (An=Pn) ,
одинаковый порядок следования (A1-P1, A2-P2..)
совместимость типов (типы одинаковы или неявно преобразованные),
одинаковый статус аргументов (если параметр объявлен с ключевым словом ref или out, то фактический аргумент должен сопровождаться таким же ключевым словом в точке вызова). 

Все формальные параметры разделяются на 3 группы: 
входные параметры – задаются без ключевого слова (или с параметром ref); передают информацию методу и их значения в теле метода только читаются;
выходные параметры – снабжаются ключевым словом out; представляют собой результаты метода, они получают значения в ходе работы метода; в теле метода должен присутствовать оператор присваивания, задающий значение этому параметру;
обновляемые параметры – снабжаются ключевым словом ref; выполняют обе функции. Их значения используются в ходе вычислений и обновляются в результате работы метода.
Например:
                                                // Процедура Cube
void Cube(out  long p2, int p1)
{
  p2 = (long)Math.Pow(p1, 3);
  Console.WriteLine("Метод );
}
                                                // Процедура CubeM
void CubeM(out  double p2, params double[ ] p)
{
  p2 =0; for (int I = 0; I < p.lehgth; i++)
  p2 + = Math.Pow(p[ i ], 3);
  Console.WriteLine("Метод );
}
                                                // Функция F
int F(ref int a)
{
  retun (a++)
}
Все методы закрыты, поскольку объявлены без модификатора доступа. Cube и CubeM – процедуры, а F – функция. Аргумент р2 – является выходным (сопровождается ключевым словом out ), поэтому в теле метода ему присваивается значение. Аргумент функции F является обновляемым (снабжен ключевым словом ref ), в теле функции используется его значение для получения результата функции, но и само значение параметра изменяется в теле функции. Для процедуры CubeM используется ключевое слово params для самого последнего аргумента р. Т.к. этому параметру будет соответствовать несколько фактических аргументов, число которых может быть произвольным. 



Области действия имен
Структура подпрограммы идентична структуре программы.
Имена, объявленные в главной программе являются глобальными. Они доступны во всех внутренних точках, в том числе и в подпрограммах.
 Имена, объявленные в методе, являются локальными. Они доступны во всех внутренних точках подпрограммы.
 Локальное имя во внешней программе недоступно. Память под них выделяется автоматически в момент вызова метода.
 Если используются одинаковые локальное и глобальное имя, то внутри метода локальное имя блокирует глобальное.

9.7 Тело метода (процедуры и функции)
Синтаксически тело метода является блоком, который представляет собой последовательность инструкций и описание переменных заключенных в {…}. 
В теле функции в блоке должен быть хотя бы один оператор, возвращающий значение функции в формате
   return <выражение>
Переменные, описанные в блоке, считаются локальными в этом блоке.
Вызов метода. Синтаксис.
Функция может быть вызвана в выражении, а процедура – как оператор тела блока. Сам вызов метода, независимо от того, процедура это или функция, имеет один и тот же синтаксис:
Имя_метода([список фактических аргументов]);
Если это оператор, то вызов завершается точкой с запятой. 
Формальный параметр представляет собой идентификатор параметра, а фактический аргумент – «выражение», значительно более сложную синтаксическую конструкцию:
[ ref | out ] выражение
В момент вызова метода происходит:
1. вычисление фактических аргументов, которые являются выражением,
2. в точке вызова создается блок, в котором происходит замена имен параметров фактическими аргументами. 
Функция
Пример 1. Написать функцию, проверяющую, является ли целое число, введенное с клавиатуры четным. Программа должна использовать эту функцию, проверять является ли число четным или нет, и выводить соответствующее сообщение.
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Text;
namespace ConsoleApplication1
{
class Program
{
static bool Chet(int n)   // Процедура "Четность"
{
 if (n % 2 == 0) return true;
else return false;              
 }
 static void Main(string[] args)
 {
int m;
Console.WriteLine("Определение четности аргумента");
Console.WriteLine();
do
{
Console.Write("m >> ");
m = Convert.ToInt32(Console.ReadLine());
if (Chet(m)) Console.WriteLine("Число четное");
else Console.WriteLine("Число нечетное");
Console.WriteLine();
}
while (m!=0);
Console.ReadLine();
  }
 }
}








Процедура 
Пример 2. Вывести таблицу квадратных корней.
Для оформления таблицы использовать процедуру Line.   
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace ConsoleApplication1
{
 class Program
{
static void Line(int n, char c) // Процедура "Рисовать линию" с параметрами n и с
  {
  for (int k = 0; k < n; k++)
Console.Write(c);
  Console.WriteLine();  // Вывод строки с символами С
        }
static void Main(string[] args)
{
int m = 18;
Console.WriteLine("Таблица квадратных корней");
Console.WriteLine();
   Line(m, '=');     // Вызов процедуры "Рисовать линию"
  Console.WriteLine(" Число | Корень");
  Line(m, '=');     // Вызов процедуры "Рисовать линию"
  for (int i = 0; i < 10; i++)
  {
  double q = Math.Sqrt(i);
Console.WriteLine("   {0}   |   {1,3:f}",i, q);
  Line(m, '-');     // Вызов процедуры "Рисовать линию"              
            }
Console.ReadLine();
        }
    }
}

     
                                         
                                                                        

Краткие итоги. В лекции были даны определения, что такое классы, объекты, методы. Представлен синтаксис класса, методы представления подпрограммы. Изучены функции и процедуры, относящиеся к подпрограмме, дано их описание.

Контрольные вопросы.
Дайте определение понятию «класс».
Что лежит в основе класса?
Каковы свойства и характеристики объекта?
Назовите спецификаторы и для чего они применяются.
Дайте определение понятиям «функция» и «процедура».
Назовите преимущества подпрограммы.
Сравните монолитную и модульную программы, назовите их различия.
Опишите методы процедур и функций.
Дайте определение что такое «параметры» и «Аргументы».
Каковы области действия имен?
Опишите процедуру вызова метода «Синтаксис»
Приведите пример работы функции.
Приведите пример работы процедуры.